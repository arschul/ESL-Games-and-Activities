<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Team Challenge Game</title>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <style>
    :root {
      --background-color: #f0f2f5;
      --text-color: #333;
      --primary-color: #4caf50; /* Green */
      --secondary-color: #f44336; /* Red */
      --accent-color: #2196f3; /* Blue */
      --card-background: #ffffff;
      --border-color: #ddd;
      --strike-color: #ffc107; /* Amber */
      --disabled-color: #ccc;
    }

    body.dark-mode {
      --background-color: #2c2c2c;
      --text-color: #e0e0e0;
      --primary-color: #66bb6a;
      --secondary-color: #ef5350;
      --accent-color: #42a5f5;
      --card-background: #3a3a3a;
      --border-color: #555;
      --strike-color: #ffeb3b;
      --disabled-color: #666;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background-color: var(--background-color);
      color: var(--text-color);
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      transition: background-color 0.3s, color 0.3s;
    }

    main {
      background-color: var(--card-background);
      border-radius: 12px;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
      padding: 30px;
      width: 90%;
      max-width: 900px;
      text-align: center;
      display: flex;
      flex-direction: column;
      gap: 25px;
      position: relative;
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    h1 {
      color: var(--accent-color);
      font-size: 2.5em;
      margin: 0;
    }

    .screen {
      display: none;
      flex-direction: column;
      gap: 20px;
      align-items: center;
    }

    .screen.active {
      display: flex;
    }

    h2 {
      color: var(--text-color);
      font-size: 2em;
      margin-bottom: 15px;
    }

    .form-group {
      margin-bottom: 15px;
      width: 100%;
      max-width: 400px;
      text-align: left;
    }

    .form-group input[type="text"],
    .form-group select {
      width: 100%;
      padding: 12px;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      background-color: var(--background-color);
      color: var(--text-color);
      font-size: 1em;
      transition: border-color 0.3s, background-color 0.3s;
    }

    .form-group input[type="text"]:focus,
    .form-group select:focus {
      outline: none;
      border-color: var(--accent-color);
      box-shadow: 0 0 0 3px rgba(var(--accent-color-rgb, 33, 150, 243), 0.2);
    }

    .button {
      background-color: var(--primary-color);
      color: white;
      padding: 14px 25px;
      border: none;
      border-radius: 8px;
      font-size: 1.1em;
      cursor: pointer;
      transition: background-color 0.3s, transform 0.1s;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }

    .button:hover {
      background-color: var(--primary-color);
      filter: brightness(1.1);
      transform: translateY(-2px);
    }

    .button:active {
      transform: translateY(0);
    }

    .icon-button {
      background: none;
      border: none;
      cursor: pointer;
      color: var(--text-color);
      transition: color 0.3s, transform 0.1s;
      padding: 10px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .icon-button .material-icons {
      font-size: 28px;
    }

    .icon-button:hover {
      color: var(--accent-color);
      transform: scale(1.1);
    }

    #darkModeToggle {
      color: var(--text-color);
    }

    #darkModeToggle:hover {
      color: var(--accent-color);
    }

    /* Game Screen Styles */
    #teams-container {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 20px;
      margin-bottom: 30px;
    }

    .team-box {
      background-color: var(--card-background);
      border: 2px solid var(--border-color);
      border-radius: 10px;
      padding: 15px 20px;
      min-width: 180px;
      text-align: center;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);
      transition: border-color 0.3s, box-shadow 0.3s, opacity 0.3s;
      position: relative;
    }

    .team-box.active {
      border-color: var(--accent-color);
      box-shadow: 0 0 0 4px rgba(var(--accent-color-rgb, 33, 150, 243), 0.3);
    }

    .team-box.out {
      opacity: 0.5;
      filter: grayscale(100%);
      pointer-events: none; /* Prevent interaction */
    }

    .team-name {
      font-size: 1.4em;
      font-weight: bold;
      margin-bottom: 10px;
      color: var(--text-color);
    }

    .strikes {
      display: flex;
      justify-content: center;
      gap: 5px;
      min-height: 24px; /* Ensure consistent height */
    }

    .strike-icon {
      color: var(--strike-color);
      font-size: 24px;
    }

    .game-area {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 25px;
    }

    .categories-display {
      display: flex;
      gap: 15px;
      margin-bottom: 15px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .category-tag {
      background-color: var(--accent-color);
      color: white;
      padding: 8px 15px;
      border-radius: 20px;
      font-size: 1.1em;
      font-weight: 500;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .prompt-text {
      font-size: 1.8em;
      font-weight: 600;
      color: var(--text-color);
      margin-bottom: 20px;
    }

    .timer-container {
      display: flex;
      align-items: center;
      gap: 10px;
      background-color: var(--background-color);
      padding: 10px 20px;
      border-radius: 30px;
      box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    .timer-icon {
      font-size: 32px;
      color: var(--secondary-color);
    }

    .timer-text {
      font-size: 2.5em;
      font-weight: bold;
      color: var(--secondary-color);
      min-width: 40px; /* Prevent jump when numbers change */
      text-align: center;
    }

    .controls {
      display: flex;
      gap: 30px; /* Reverted gap for main controls */
      margin-top: 20px;
      justify-content: center; /* Center the main controls */
    }

    .correct-button,
    .incorrect-button {
      padding: 15px;
      border-radius: 50%;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      border: none;
      cursor: pointer;
      transition: background-color 0.3s, transform 0.1s;
    }

    .correct-button {
      background-color: var(--primary-color);
      color: white;
    }

    .incorrect-button {
      background-color: var(--secondary-color);
      color: white;
    }

    .correct-button:hover {
      background-color: var(--primary-color);
      filter: brightness(1.1);
    }

    .incorrect-button:hover {
      background-color: var(--secondary-color);
      filter: brightness(1.1);
    }

    .correct-button .material-icons,
    .incorrect-button .material-icons {
      font-size: 48px;
    }

    /* New styles for team ability buttons */
    .team-abilities {
      display: flex;
      justify-content: center;
      gap: 8px; /* Smaller gap for abilities within team box */
      margin-top: 10px;
    }

    .team-ability-button {
      background-color: var(--accent-color);
      color: white;
      padding: 8px; /* Smaller padding */
      border-radius: 50%;
      border: none;
      cursor: pointer;
      transition: background-color 0.3s, transform 0.1s, opacity 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .team-ability-button .material-icons {
      font-size: 24px; /* Smaller icons */
    }

    .team-ability-button:hover:not(:disabled) {
      filter: brightness(1.1);
      transform: translateY(-1px);
    }

    .team-ability-button:disabled {
      background-color: var(--disabled-color);
      cursor: not-allowed;
      opacity: 0.7;
      box-shadow: none;
    }

    /* Responsive adjustments for ability buttons */
    @media (max-width: 768px) {
      .team-ability-button .material-icons {
        font-size: 20px;
      }
      .team-ability-button {
        padding: 6px;
      }
    }

    @media (max-width: 480px) {
      .team-ability-button .material-icons {
        font-size: 18px;
      }
      .team-ability-button {
        padding: 5px;
      }
      .team-abilities {
        gap: 5px;
      }
    }

    /* Game Over Screen */
    .winner-message {
      font-size: 2em;
      font-weight: bold;
      color: var(--primary-color);
      margin-bottom: 20px;
    }

    /* Modal Styles */
    .modal {
      display: none; /* Hidden by default */
      position: fixed; /* Stay in place */
      z-index: 1000; /* Sit on top */
      left: 0;
      top: 0;
      width: 100%; /* Full width */
      height: 100%; /* Full height */
      overflow: auto; /* Enable scroll if needed */
      background-color: rgba(0, 0, 0, 0.4); /* Black w/ opacity */
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
    }

    .modal.show {
      opacity: 1;
      visibility: visible;
    }

    .modal-content {
      background-color: var(--card-background);
      margin: auto;
      padding: 30px;
      border-radius: 10px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      max-width: 400px;
      text-align: center;
      transform: translateY(-20px);
      transition: transform 0.3s ease;
    }

    .modal.show .modal-content {
      transform: translateY(0);
    }

    #modal-text {
      font-size: 1.5em;
      font-weight: bold;
      color: var(--text-color);
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      main {
        padding: 20px;
        width: 95%;
      }

      h1 {
        font-size: 2em;
      }

      h2 {
        font-size: 1.8em;
      }

      .prompt-text {
        font-size: 1.5em;
      }

      .timer-text {
        font-size: 2em;
      }

      .correct-button .material-icons,
      .incorrect-button .material-icons {
        font-size: 40px;
      }

      .team-box {
        min-width: 150px;
        padding: 10px 15px;
      }

      .team-name {
        font-size: 1.2em;
      }

      .category-tag {
        font-size: 1em;
        padding: 6px 12px;
      }
    }

    @media (max-width: 480px) {
      main {
        padding: 15px;
      }

      h1 {
        font-size: 1.8em;
      }

      h2 {
        font-size: 1.5em;
      }

      .form-group {
        margin-bottom: 10px;
      }

      .button {
        padding: 12px 20px;
        font-size: 1em;
      }

      .prompt-text {
        font-size: 1.2em;
      }

      .timer-text {
        font-size: 1.8em;
      }

      .controls {
        gap: 10px; /* Even smaller gap for very small screens */
      }

      .correct-button .material-icons,
      .incorrect-button .material-icons {
        font-size: 36px;
      }

      .team-box {
        min-width: 120px;
      }

      .team-name {
        font-size: 1.1em;
      }
    }

    /* Styles for stars */
    .stars-display {
      display: flex;
      justify-content: center;
      gap: 3px; /* Smaller gap for stars */
      margin-bottom: 5px; /* Space between stars and name */
      min-height: 24px; /* Consistent height */
    }

    .star-icon {
      color: gold; /* Or any other star color */
      font-size: 20px; /* Smaller than strike icons */
    }
  </style>
</head>
<body>
  <main>
      <header>
          <h1>Team Challenge</h1>
          <button id="darkModeToggle" class="icon-button" aria-label="Toggle dark mode">
              <span class="material-icons">dark_mode</span>
          </button>
      </header>

      <section id="setup-screen" class="screen active">
          <h2>Game Setup</h2>
          <div class="form-group">
              <label for="numTeams">Number of Teams:</label>
              <select id="numTeams">
                  <option value="2">2</option>
                  <option value="3">3</option>
                  <option value="4">4</option>
              </select>
          </div>
          <div id="teamNameInputs">
              <div class="form-group">
                  <label for="team1Name">Team 1 Name:</label>
                  <input type="text" id="team1Name" value="Team Alpha" placeholder="Enter Team 1 Name">
              </div>
              <div class="form-group">
                  <label for="team2Name">Team 2 Name:</label>
                  <input type="text" id="team2Name" value="Team Beta" placeholder="Enter Team 2 Name">
              </div>
          </div>
          <button id="startGameBtn" class="button">Start Game</button>
      </section>

      <section id="game-screen" class="screen">
          <div id="teams-container">
              <!-- Team boxes will be dynamically inserted here -->
          </div>

          <div class="game-area">
              <div class="categories-display">
                  <span id="category1" class="category-tag">Category 1</span>
                  <span id="category2" class="category-tag">Category 2</span>
              </div>
              <p id="prompt" class="prompt-text"></p>
              <div class="timer-container">
                  <span class="material-icons timer-icon">timer</span>
                  <span id="timer" class="timer-text">30</span>
                  <button id="pauseBtn" class="icon-button team-ability-button" aria-label="Pause timer"> <!-- Moved Pause Button -->
                      <span class="material-icons">pause</span>
                  </button>
              </div>
              <div class="controls">
                  <button id="correctBtn" class="icon-button correct-button" aria-label="Correct answer">
                      <span class="material-icons">check_circle</span>
                  </button>
                  <button id="incorrectBtn" class="icon-button incorrect-button" aria-label="Incorrect answer">
                      <span class="material-icons">cancel</span>
                  </button>
              </div>
          </div>
      </section>

      <section id="game-over-screen" class="screen">
          <h2>Game Over!</h2>
          <p id="winnerMessage" class="winner-message"></p>
          <button id="playAgainBtn" class="button">Play Again</button>
      </section>

      <div id="message-modal" class="modal">
          <div class="modal-content">
              <p id="modal-text"></p>
          </div>
      </div>
  </main>

  <!-- Sound Elements (using online free sound files) -->
  <audio id="correctSound" src="https://www.soundjay.com/buttons/button-1.mp3" preload="auto"></audio>
  <audio id="incorrectSound" src="https://www.soundjay.com/buttons/button-2.mp3" preload="auto"></audio>
  <audio id="strikeSound" src="https://www.soundjay.com/misc/fail-buzzer-01.mp3" preload="auto"></audio>
  <audio id="timerEndSound" src="https://www.soundjay.com/misc/fail-buzzer-02.mp3" preload="auto"></audio>
  <audio id="winSound" src="https://www.soundjay.com/misc/success-sound-effect.mp3" preload="auto"></audio>

  <script>
    // --- DOM Elements ---
    const setupScreen = document.getElementById("setup-screen")
    const gameScreen = document.getElementById("game-screen")
    const gameOverScreen = document.getElementById("game-over-screen")

    const numTeamsSelect = document.getElementById("numTeams")
    const teamNameInputsDiv = document.getElementById("teamNameInputs")
    const startGameBtn = document.getElementById("startGameBtn")

    const teamsContainer = document.getElementById("teams-container")
    const category1Span = document.getElementById("category1")
    const category2Span = document.getElementById("category2")
    const promptText = document.getElementById("prompt")
    const timerDisplay = document.getElementById("timer")
    const correctBtn = document.getElementById("correctBtn")
    const incorrectBtn = document.getElementById("incorrectBtn")
    const pauseBtn = document.getElementById("pauseBtn")

    const winnerMessage = document.getElementById("winnerMessage")
    const playAgainBtn = document.getElementById("playAgainBtn")

    const darkModeToggle = document.getElementById("darkModeToggle")
    const messageModal = document.getElementById("message-modal")
    const modalText = document.getElementById("modal-text")

    // --- Game State Variables ---
    let teams = []
    let currentTeamIndex = 0
    let timerInterval
    let timeLeft = 30
    let gameStarted = false
    let isTimerRunning = false;
    let isTimerPaused = false;

    // --- Category Data (100 easy categories) ---
    const allCategoryNames = [
      "Fruits", "Animals", "Movies", "TV Series", "Car Brands", "Colors", "Kitchen Utensils", "Clothing Items", "Sports", "Musical Instruments",
      "Superheroes", "Vegetables", "Tools", "Professions", "Body Parts", "Planets", "Countries", "Cities", "Famous Landmarks", "Trees",
      "Flowers", "Birds", "Fish", "Insects", "Reptiles", "Amphibians", "Mammals", "Desserts", "Drinks", "Breakfast Foods",
      "Lunch Foods", "Dinner Foods", "Spices", "Herbs", "Grains", "Legumes", "Dairy Products", "Meats", "Seafood", "Fast Food Chains",
      "Restaurants", "School Subjects", "Hobbies", "Sports Equipment", "Board Games", "Card Games", "Video Game Genres", "Computer Brands", "Phone Brands", "Social Media Platforms",
      "Websites", "Apps", "Programming Languages", "Jobs in Tech", "Musical Genres", "Dance Styles", "Art Forms", "Famous Artists", "Famous Scientists", "Historical Figures",
      "Mythological Creatures", "Fairy Tale Characters", "Cartoon Characters", "Disney Characters", "Pixar Movies", "DreamWorks Movies", "TV Show Genres", "Book Genres", "Authors", "Poets",
      "Types of Houses", "Rooms in a House", "Furniture", "Appliances", "Weather Phenomena", "Natural Disasters", "Gemstones", "Metals", "Elements (Periodic Table)", "Chemical Compounds",
      "Units of Measurement", "Shapes", "Numbers", "Letters", "Punctuation Marks", "Emotions", "Feelings", "Adjectives", "Verbs", "Nouns",
      "Adverbs", "Prepositions", "Conjunctions", "Interjections", "Holidays", "Seasons", "Months", "Days of the Week", "Continents", "Oceans"
    ];

    let activeCategories = [] // e.g., ['fruits', 'carBrands']
    let availableCategoriesForSession = []; // Categories available for the entire game session

    // --- Sound Effects ---
    const soundEffects = {
      correct: document.getElementById("correctSound"),
      incorrect: document.getElementById("incorrectSound"),
      strike: document.getElementById("strikeSound"),
      timerEnd: document.getElementById("timerEndSound"),
      win: document.getElementById("winSound"),
    }

    // --- Utility Functions ---
    function showScreen(screen) {
      document.querySelectorAll(".screen").forEach((s) => s.classList.remove("active"))
      screen.classList.add("active")
    }

    function showMessage(message, duration = 2000) {
      modalText.textContent = message
      messageModal.classList.add("show")
      setTimeout(() => {
        modalText.textContent = ""; // Clear text after hiding
        messageModal.classList.remove("show")
      }, duration)
    }

    function playSound(soundName) {
      if (soundEffects[soundName]) {
        soundEffects[soundName].currentTime = 0 // Rewind to start
        soundEffects[soundName].play().catch((e) => console.error("Error playing sound:", e))
      }
    }

    // --- Game Setup Logic ---
    function generateTeamNameInputs(num) {
      teamNameInputsDiv.innerHTML = ""
      for (let i = 1; i <= num; i++) {
        const div = document.createElement("div")
        div.classList.add("form-group")
        div.innerHTML = `
              <label for="team${i}Name">Team ${i} Name:</label>
              <input type="text" id="team${i}Name" value="Team ${String.fromCharCode(64 + i)}" placeholder="Enter Team ${i} Name">
          `
        teamNameInputsDiv.appendChild(div)
      }
    }

    numTeamsSelect.addEventListener("change", (e) => {
      generateTeamNameInputs(Number.parseInt(e.target.value))
    })

    startGameBtn.addEventListener("click", () => {
      const numTeams = Number.parseInt(numTeamsSelect.value)
      teams = []
      let allNamesValid = true

      for (let i = 1; i <= numTeams; i++) {
        const nameInput = document.getElementById(`team${i}Name`)
        const name = nameInput.value.trim()
        if (!name) {
          allNamesValid = false
          nameInput.style.borderColor = "var(--secondary-color)"
          setTimeout(() => (nameInput.style.borderColor = "var(--border-color)"), 1500)
          showMessage(`Please enter a name for Team ${i}.`)
          return
        }
        teams.push({
          name: name,
          strikes: 0,
          stars: 0,
          isOut: false,
          hasSwitched: false, // New ability tracker
          hasSkipped: false, // New ability tracker
          hasExtendedTimer: false, // New ability tracker
        })
      }

      if (allNamesValid) {
        gameStarted = true
        availableCategoriesForSession = [...allCategoryNames]; // Initialize for the session
        initGame()
        startRound()
        showScreen(gameScreen)
      }
    })

    // --- Game Core Logic ---
    function initGame() {
      currentTeamIndex = 0
      startNewRound(false); // Call startNewRound for initial setup, don't show message
      renderTeams(); // Initial render of teams with 0 strikes and 0 stars
    }

    function renderTeams() {
      teamsContainer.innerHTML = ""
      teams.forEach((team, index) => {
        const teamBox = document.createElement("div")
        teamBox.classList.add("team-box")
        teamBox.dataset.teamIndex = index
        teamBox.innerHTML = `
          <div class="stars-display"></div>
          <div class="team-name">${team.name}</div>
          <div class="strikes"></div>
          <div class="team-abilities">
            <button class="team-ability-button" data-ability-type="switch" aria-label="Switch categories">
              <span class="material-icons">delete</span>
            </button>
            <button class="team-ability-button" data-ability-type="skip" aria-label="Skip turn">
              <span class="material-icons">skip_next</span>
            </button>
            <button class="team-ability-button" data-ability-type="extendTimer" aria-label="Extend timer">
              <span class="material-icons">timer</span>
            </button>
          </div>
        `
        teamsContainer.appendChild(teamBox)

        // Attach event listeners to the newly created buttons for this team
        teamBox.querySelector('[data-ability-type="switch"]').addEventListener("click", () => handleSwitch(index))
        teamBox.querySelector('[data-ability-type="skip"]').addEventListener("click", () => handleSkip(index))
        teamBox.querySelector('[data-ability-type="extendTimer"]').addEventListener("click", () => handleExtendTimer(index))

        updateTeamBox(index) // Initial update for strikes, stars, and active state
      })
    }

    function updateTeamBox(index) {
      const teamBox = teamsContainer.querySelector(`[data-team-index="${index}"]`)
      if (!teamBox) return

      const team = teams[index]
      const strikesDiv = teamBox.querySelector(".strikes")
      const starsDiv = teamBox.querySelector(".stars-display")

      // Update strikes
      strikesDiv.innerHTML = ""
      for (let i = 0; i < team.strikes; i++) {
        const strikeIcon = document.createElement("span")
        strikeIcon.classList.add("material-icons", "strike-icon")
        strikeIcon.textContent = "close"
        strikesDiv.appendChild(strikeIcon)
      }

      // Update stars
      starsDiv.innerHTML = ""
      for (let i = 0; i < team.stars; i++) {
        const starIcon = document.createElement("span")
        starIcon.classList.add("material-icons", "star-icon")
        starIcon.textContent = "star"
        starsDiv.appendChild(starIcon)
      }

      // Highlight active team
      document.querySelectorAll(".team-box").forEach((box) => box.classList.remove("active"))
      if (!team.isOut) {
        teamBox.classList.add("active")
      }

      // Mark team as out
      if (team.isOut) {
        teamBox.classList.add("out")
      } else {
        teamBox.classList.remove("out")
      }

      // Get ability buttons for this specific team box
      const teamSwitchBtn = teamBox.querySelector('[data-ability-type="switch"]')
      const teamSkipBtn = teamBox.querySelector('[data-ability-type="skip"]')
      const teamExtendTimerBtn = teamBox.querySelector('[data-ability-type="extendTimer"]')

      // Enable/disable ability buttons based on current team and usage
      if (index === currentTeamIndex && !team.isOut) {
        if (teamSwitchBtn) teamSwitchBtn.disabled = team.hasSwitched
        if (teamSkipBtn) teamSkipBtn.disabled = team.hasSkipped
        if (teamExtendTimerBtn) teamExtendTimerBtn.disabled = team.hasExtendedTimer
      } else {
        // Disable all ability buttons if it's not the current team's turn or team is out
        if (teamSwitchBtn) teamSwitchBtn.disabled = true
        if (teamSkipBtn) teamSkipBtn.disabled = true
        if (teamExtendTimerBtn) teamExtendTimerBtn.disabled = true
      }
    }

    function updateCategoriesDisplay() {
      category1Span.textContent = activeCategories[0]
      category2Span.textContent = activeCategories[1]
      promptText.textContent = ""; // Ensure no text is displayed here
    }

    function startRound() {
      // Reset ability usage at the start of each round
      teams.forEach((team) => {
        team.hasSwitched = false
        team.hasSkipped = false
        team.hasExtendedTimer = false
      })
      nextTurn()
    }

    function nextTurn() {
      stopTimer(); // Stop any existing timer

      const totalTeams = teams.length;
      let nextIndex = (currentTeamIndex + 1) % totalTeams;
      let foundNextTeam = false;

      // Iterate through all teams to find the next active one
      for (let i = 0; i < totalTeams; i++) {
        if (!teams[nextIndex].isOut) {
          currentTeamIndex = nextIndex; // Update currentTeamIndex to the found active team
          foundNextTeam = true;
          break;
        }
        nextIndex = (nextIndex + 1) % totalTeams; // Move to the next team in the circle
      }

      if (!foundNextTeam) {
        // This means all teams are out, or only one is left.
        // checkGameOver will handle the end of round/game.
        checkGameOver();
        return;
      }

      updateTeamBox(currentTeamIndex); // Highlight the new active team and update ability buttons
      timeLeft = 30; // Reset timer for new turn
      updateTimerDisplay();
      startTimer(); // Start timer for the new turn
    }

    function startTimer() {
      if (isTimerRunning) return; // Prevent multiple intervals

      isTimerRunning = true;
      isTimerPaused = false;
      pauseBtn.querySelector(".material-icons").textContent = "pause";
      pauseBtn.setAttribute("aria-label", "Pause timer");

      timerInterval = setInterval(() => {
        timeLeft--;
        updateTimerDisplay();
        if (timeLeft <= 0) {
          handleStrike(true); // Timer ran out
        }
      }, 1000);
    }

    function stopTimer() {
      clearInterval(timerInterval);
      isTimerRunning = false;
      isTimerPaused = true; // When stopped by action, it's paused
      pauseBtn.querySelector(".material-icons").textContent = "play_arrow";
      pauseBtn.setAttribute("aria-label", "Resume timer");
    }

    function togglePause() {
      if (isTimerRunning) {
        stopTimer(); // This will pause it
      } else if (isTimerPaused) {
        startTimer(); // This will resume it
      } else {
        // If timer is not running and not paused (e.g., first turn), start it
        startTimer();
      }
    }

    function updateTimerDisplay() {
      timerDisplay.textContent = timeLeft
      if (timeLeft <= 10 && timeLeft > 0) {
        timerDisplay.style.color = "var(--secondary-color)"
      } else {
        timerDisplay.style.color = "var(--secondary-color)" // Always red for timer
      }
    }

    function handleCorrect() {
      playSound("correct")
      stopTimer(); // Pause timer
      nextTurn()
    }

    function handleIncorrect() {
      playSound("incorrect")
      handleStrike(false)
    }

    function handleStrike(timerExpired) {
      const currentTeam = teams[currentTeamIndex]
      currentTeam.strikes++
      playSound("strike")
      stopTimer(); // Pause timer
      updateTeamBox(currentTeamIndex)

      let message = `${currentTeam.name} got a strike!`
      if (timerExpired) {
        message = `${currentTeam.name}'s time ran out! Strike!`
        playSound("timerEnd")
      }
      showMessage(message)

      // Change one of the categories
      if (availableCategoriesForSession.length > 0) {
        const categoryToReplaceIndex = Math.floor(Math.random() * activeCategories.length)
        const oldCategory = activeCategories[categoryToReplaceIndex]

        let newCategory;
        let attempts = 0;
        do {
          if (availableCategoriesForSession.length === 0) {
            console.warn("No more unique categories left in the session pool!");
            newCategory = "No More Categories"; // Fallback if all categories are used
            break;
          }
          const randomIndex = Math.floor(Math.random() * availableCategoriesForSession.length);
          newCategory = availableCategoriesForSession[randomIndex];
          attempts++;
          if (attempts > 200) { // Increased attempts to be safe with 100 categories
            console.warn("Could not find a unique new category after many attempts. Reusing a category from the full list.");
            newCategory = allCategoryNames[Math.floor(Math.random() * allCategoryNames.length)]; // Fallback to full list if session pool exhausted
            break;
          }
        } while (activeCategories.includes(newCategory));

        activeCategories[categoryToReplaceIndex] = newCategory;
        // Remove the new category from the session's available pool
        availableCategoriesForSession = availableCategoriesForSession.filter((cat) => cat !== newCategory);

        updateCategoriesDisplay();
      } else {
        console.warn("No more categories to change to!");
      }

      if (currentTeam.strikes >= 3) {
        currentTeam.isOut = true
        updateTeamBox(currentTeamIndex)
        showMessage(`${currentTeam.name} is out!`, 3000)
        // After a team is out, check game over conditions.
        // If game is not over, nextTurn will be called by checkGameOver or startNewRound.
        checkGameOver();
      } else {
        nextTurn(); // If team is not out, just move to the next turn
      }
    }

    function checkGameOver() {
      stopTimer(); // Always stop timer when checking game over

      const activeTeams = teams.filter((team) => !team.isOut);

      // Scenario 1: A team has reached 3 stars (overall game win)
      const winnerByStars = teams.find(team => team.stars >= 3);
      if (winnerByStars) {
        gameStarted = false;
        winnerMessage.innerHTML = `Congratulations, <span style="color: var(--primary-color);">${winnerByStars.name}</span>! You win the game with 3 stars! <span class="material-icons" style="font-size: 2em; vertical-align: middle;">star</span>`;
        playSound("win");
        showScreen(gameOverScreen);
        return; // Game over
      }

      // Scenario 2: Only one team left standing in the current round (round win)
      if (activeTeams.length === 1) {
        const roundWinner = activeTeams[0];
        roundWinner.stars++; // Award a star to the last team standing
        updateTeamBox(teams.indexOf(roundWinner)); // Update UI to show new star

        playSound("win"); // Play win sound for round
        showMessage(`${roundWinner.name} is the last team standing and gets a star!`, 3000);

        // Check if this round win also leads to overall game win
        if (roundWinner.stars >= 3) {
          gameStarted = false;
          winnerMessage.innerHTML = `Congratulations, <span style="color: var(--primary-color);">${roundWinner.name}</span>! You win the game with 3 stars! <span class="material-icons" style="font-size: 2em; vertical-align: middle;">star</span>`;
          showScreen(gameOverScreen);
        } else {
          // If not overall game win, prepare for next round
          setTimeout(() => {
            startNewRound(true); // Pass true to show "New Round!" message
          }, 3500); // Give time for message to display
        }
        return; // Round ended, transition handled
      }

      // Scenario 3: All teams eliminated (draw for the round/game)
      if (activeTeams.length === 0) {
        gameStarted = false;
        winnerMessage.textContent = "It's a draw! No teams left standing.";
        showScreen(gameOverScreen);
        return; // Game over
      }

      // Scenario 4: A team was eliminated, but multiple teams are still active in the current round.
      // In this case, the game continues in the same round, and we need to move to the next active team.
      // This is handled by the `nextTurn()` call in `handleStrike()` if `checkGameOver()` doesn't
      // result in a full state change.
    }

    function startNewRound(showMessageFlag = false) {
      // Reset strikes and 'isOut' status for all teams, but keep stars
      teams.forEach(team => {
        team.strikes = 0;
        team.isOut = false; // Bring all teams back into play
        // Reset abilities for the new round
        team.hasSwitched = false;
        team.hasSkipped = false;
        team.hasExtendedTimer = false;
      });

      activeCategories = [];
      // Pick new categories from the session's available pool
      for (let i = 0; i < 2; i++) {
        if (availableCategoriesForSession.length === 0) {
          console.warn("Ran out of unique categories for the session!");
          // Fallback: if no more unique categories, maybe reuse from full list or end game
          // For now, we'll just pick from the full list if the unique pool is exhausted.
          const randomIndex = Math.floor(Math.random() * allCategoryNames.length);
          activeCategories.push(allCategoryNames[randomIndex]);
        } else {
          const randomIndex = Math.floor(Math.random() * availableCategoriesForSession.length);
          activeCategories.push(availableCategoriesForSession[randomIndex]);
          availableCategoriesForSession.splice(randomIndex, 1); // Remove from session pool
        }
      }

      renderTeams(); // Re-render team boxes to clear strikes, activate all teams, and update ability buttons
      updateCategoriesDisplay();

      currentTeamIndex = 0;
      
      if (showMessageFlag) {
        showMessage("New Round!", 2000);
        setTimeout(() => {
          nextTurn(); // Start the first turn of the new round after message
        }, 2500);
      } else {
        // For initial game setup, just start the turn immediately
        nextTurn();
      }
    }

    // --- New Ability Functions ---
    function handleSwitch(teamIndex) {
      // Ensure only the current active team can use abilities
      if (teamIndex !== currentTeamIndex) {
        showMessage("It's not your team's turn to use an ability!", 1500);
        return;
      }

      const currentTeam = teams[teamIndex];
      if (currentTeam.hasSwitched) {
        showMessage("You've already used your Switch for this round!", 1500);
        return;
      }

      if (availableCategoriesForSession.length < 2) { // Need at least 2 categories to switch both
        showMessage("Not enough unique categories left to switch!", 2000);
        return;
      }

      currentTeam.hasSwitched = true;
      updateTeamBox(teamIndex); // Disable the button

      // Replace both active categories with new ones from the session pool
      activeCategories = [];
      for (let i = 0; i < 2; i++) {
        const randomIndex = Math.floor(Math.random() * availableCategoriesForSession.length);
        activeCategories.push(availableCategoriesForSession[randomIndex]);
        availableCategoriesForSession.splice(randomIndex, 1);
      }
      updateCategoriesDisplay();

      timeLeft = 30; // Reset timer
      updateTimerDisplay();
      stopTimer(); // Pause after action
      startTimer(); // Restart timer

      showMessage(`${currentTeam.name} used their Switch! New categories!`, 2000);
    }

    function handleSkip(teamIndex) {
      // Ensure only the current active team can use abilities
      if (teamIndex !== currentTeamIndex) {
        showMessage("It's not your team's turn to use an ability!", 1500);
        return;
      }

      const currentTeam = teams[teamIndex];
      if (currentTeam.hasSkipped) {
        showMessage("You've already used your Skip for this round!", 1500);
        return;
      }

      currentTeam.hasSkipped = true;
      updateTeamBox(teamIndex); // Disable the button

      stopTimer(); // Pause timer
      nextTurn(); // Move to next team

      showMessage(`${currentTeam.name} used their Skip!`, 1500);
    }

    function handleExtendTimer(teamIndex) {
      // Ensure only the current active team can use abilities
      if (teamIndex !== currentTeamIndex) {
        showMessage("It's not your team's turn to use an ability!", 1500);
        return;
      }

      const currentTeam = teams[teamIndex];
      if (currentTeam.hasExtendedTimer) {
        showMessage("You've already used your Timer Extender for this round!", 1500);
        return;
      }

      currentTeam.hasExtendedTimer = true;
      updateTeamBox(teamIndex); // Disable the button

      timeLeft += 45; // Add 45 seconds
      updateTimerDisplay();
      
      showMessage(`${currentTeam.name} extended the timer by 45 seconds!`, 2000);
    }

    // --- Event Listeners ---
    correctBtn.addEventListener("click", handleCorrect)
    incorrectBtn.addEventListener("click", handleIncorrect)
    pauseBtn.addEventListener("click", togglePause);

    playAgainBtn.addEventListener("click", () => {
      showScreen(setupScreen)
      generateTeamNameInputs(Number.parseInt(numTeamsSelect.value))
    })

    darkModeToggle.addEventListener("click", () => {
      document.body.classList.toggle("dark-mode")
      const icon = darkModeToggle.querySelector(".material-icons")
      if (document.body.classList.contains("dark-mode")) {
        icon.textContent = "light_mode"
        darkModeToggle.setAttribute("aria-label", "Toggle light mode")
      } else {
        icon.textContent = "dark_mode"
        darkModeToggle.setAttribute("aria-label", "Toggle dark mode")
      }
    })

    // --- Initial Setup ---
    document.addEventListener("DOMContentLoaded", () => {
      generateTeamNameInputs(Number.parseInt(numTeamsSelect.value))
      showScreen(setupScreen)
    })
  </script>
</body>
</html>
